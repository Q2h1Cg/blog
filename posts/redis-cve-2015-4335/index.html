<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="robots" content="index,follow" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Chu" />
    <meta name="description" content="Chu 的博客" />
    <meta name="keywords" content="Chu,网络安全,编程开发" />

    <title>Redis CVE-2015-4335 分析 - Chu&#39;s BLoG</title>

    
    
    
    <link rel="stylesheet" href="/css/main.5d65992f9b793fc8ef4d51468c16f848fbe23ebfca8a5cd9508abf8cc4389cc7.css" integrity="sha256-XWWZL5t5P8jvTVFGjBb4SPviPr/KilzZUIq/jMQ4nMc=" />
    <link rel="alternate" href="/index.xml" type="application/atom+xml" title="RSS" />
</head>

<body>
    <header></header>
    <main>
<article>
    <header>
        <h1>Redis CVE-2015-4335 分析</h1>
        <div>
            <time datetime="2018-06-26 20:16:45 +0800 CST">发布时间: 2018-06-26 20:16</time>
            <time datetime="2018-06-26 20:16:45 +0800 CST">更新时间: 2018-06-26 20:16</time>
        </div>
    </header>

    <section>
    <h2 id="1-漏洞分析">1. 漏洞分析</h2>
<p>利用到的漏洞分别为 <code>OP_FORPREP/OP_FORLOOP</code>、<code>OP_CLOSURE</code> 中的类型混淆，这里以 Redis 2.8.20 版本进行分析。</p>
<h3 id="1-op_forprepop_forloop">1) <code>OP_FORPREP/OP_FORLOOP</code></h3>
<p>lua 中对 <code>for</code> 循环生成的字节码如下：</p>
<p><img src="1.jpeg" alt=""></p>
<p>可以看到 for 循环是由 <code>FORPREP</code>、<code>FORLOOP</code> 两条指令组合而来，对应的源码是 deps/lua/src/lvm.c line 654-680：</p>
<p><img src="2.jpeg" alt=""></p>
<p>在 <code>OP_FORPREP</code> 中，lua 对参数进行类型检查，判断是否为 number 类型，不是则触发错误；然而在 <code>OP_FORLOOP</code> 中，因已做过类型检查，便假定参数为 number 类型，并对其执行 <code>idx = idx + step</code> 操作，这导致任意类型到 number 类型的混淆。</p>
<p>如下修改字节码中的 <code>FORPREP</code> 指令（<code>\96%z%z\128</code>）为 JMP 指令（<code>\22\0\0\128</code>），跳过 <code>OP_FORPREP</code> 中的类型检查，直接进入 <code>OP_FORLOOP</code>：</p>
<p><img src="3.jpeg" alt=""></p>
<p>测试如下：</p>
<p><img src="4.jpeg" alt=""></p>
<h3 id="2-op_closure">2) <code>OP_CLOSURE</code></h3>
<p>对 <code>CLOSURE</code> 指令的处理位于 deps/lua/src/lvm.c line 723-742：</p>
<p><img src="5.jpeg" alt=""></p>
<p>line 731-737 是对闭包的处理，具体为在 <code>CLOSURE</code> 指令后后生成对应的 <code>MOVE</code> 指令，<code>MOVE</code> 指令的第二个参数为闭包变量引用。正常情况下引用只能指向当前栈桢中的局部变量，但通过修改字节码，可以将其指向至任意位置。</p>
<p><img src="6.jpeg" alt=""></p>
<p>如上，通过修改 <code>(\100%z%z%z)....</code>（MOVE 0 0）为 <code>%1\0\0\0\1</code>（MOVE 0 2），将 <code>middle</code> 函数中的 <code>magic</code> 引用指向 <code>middle</code> 函数自身（R2），所以输出的结果为 <code>middle</code> 函数。</p>
<p>对函数调用的处理位于 deps/lua/src/lvm.c line 586-606：</p>
<p><img src="7.jpeg" alt=""></p>
<p>对函数返回的处理位于 deps/lua/src/lvm.c line 382-390：</p>
<p><img src="8.jpeg" alt=""></p>
<p>line 385 将 <code>L-&gt;ci-&gt;func</code>（当前函数指针）转换为 <code>Closure</code> 指针，由上文可知，通过修改字节码可以将闭包变量引用指向当前函数指针，导致任意类型到 <code>Closure</code> 类型的混淆。</p>
<p>基于此，结合 number 类型混淆，可以做任意地址读/写：</p>
<p><img src="9.jpeg" alt=""></p>
<p>结尾处修改字节码，将 <code>middle/inner</code> 函数中的 <code>magic</code> 引用指向 <code>middle</code> 函数；<code>inner</code> 函数中将 <code>magic</code> 赋值为字符串，这使得 <code>middle</code> 函数中的当前函数指针将被混淆为该字符串，函数返回； <code>middle</code> 函数中读取闭包变量 <code>magic</code>，读取闭包变量对应的源码为 deps/lua/src/lvm.c line 427-431：</p>
<p><img src="10.jpeg" alt=""></p>
<p>其实际上是去当前函数指针的 <code>upvals</code> 字段中获取相应引用，而当前函数指针已被混淆为字符串，对应的 <code>upvals</code> 字段可控。</p>
<p><code>TString</code> 类型与 <code>Closure</code> 类型的结构如下：</p>
<p><img src="t1.png" alt=""></p>
<p>变量 <code>upval</code> 为字符串，<code>as_double(upval)</code> 获取其 <code>TString</code> 指针，偏移 24 获取到 <code>upval-&gt;str</code> 地址，也就是说 <code>cl-&gt;p</code>、<code>cl-&gt;upvals[0]</code> 都指向输入的字符串 <code>&quot;commonhead16bits&quot; .. p32(lo) .. p32(hi)</code>。</p>
<p><code>UpVal</code> 结构如下：</p>
<p><img src="t2.png" alt=""></p>
<p>所以 <code>cl-&gt;upvals[0]-&gt;v</code> 指向构造的指针 <code>p32(lo) .. p32(hi)</code>，也即为 <code>addr</code>。</p>
<p>以上，便将任意地址的前 8 字节读取出来，写操作也是同理，只需要在 <code>middle</code> 函数中对 <code>magic</code> 赋值，需注意的是写操作实际会写入 8 字节数值及 4 字节 <code>tt</code> 类型：</p>
<p>deps/lua/src/lvm.c line 451-456：</p>
<p><img src="11.jpeg" alt=""></p>
<p>deps/lua/src/lobject.h line 161-164：</p>
<p><img src="12.webp" alt=""></p>
<p>测试如下：</p>
<p><img src="13.jpeg" alt=""></p>
<h2 id="2-漏洞利用">2. 漏洞利用</h2>
<p>具备任意地址读/写能力后是一定可以做代码执行的，目前想到如下两种方案。</p>
<h3 id="1-覆写-cclosure-f">1) 覆写 <code>CClosure-&gt;f</code></h3>
<p>在 lua 中可以使用 <code>coroutine.wrap</code> 创建 C 函数闭包对象 <code>CClosure</code>，其结构如下：</p>
<p><img src="t3.png" alt=""></p>
<p><code>CClosure-&gt;f</code> 指向函数指针，调用其对应的源码为 deps/lua/src/ldo.c 307-326：</p>
<p><img src="14.webp" alt=""></p>
<h3 id="2-覆写-got">2) 覆写 got</h3>
<p>Linux PWN 常规思路，通过 DynELF 解析 Binary，进一步解析 libc，获取 <code>system</code> 地址并覆写至 fputs.got；在 lua 中调用 <code>print(&quot;id&quot;)</code> 即可执行命令。</p>
<p><img src="15.webp" alt=""></p>
<h2 id="3-漏洞修复">3. 漏洞修复</h2>
<p>两个漏洞都是因为加载字节码导致的，Redis 中的修复简单粗暴，直接干掉了字节码加载：https://github.com/antirez/redis/commit/49efe300af258e83f377cd8142d2c67d66fc2e3a</p>
<p><img src="16.webp" alt=""></p>
<h2 id="4-参考">4. 参考</h2>
<ul>
<li><a href="https://gist.github.com/corsix/6575486">https://gist.github.com/corsix/6575486</a></li>
<li><a href="https://apocrypha.numin.it/talks/lua_bytecode_exploitation.pdf">https://apocrypha.numin.it/talks/lua_bytecode_exploitation.pdf</a></li>
</ul>

    </section>
</article>
</main>
</body>

</html>
