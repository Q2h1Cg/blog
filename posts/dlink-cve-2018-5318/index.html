<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="robots" content="index,follow" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Chu" />
    <meta name="description" content="Chu 的博客" />
    <meta name="keywords" content="Chu,网络安全,编程开发" />

    <title>CVE-2018-5318：D-Link soap.cgi Stack Buffer Overflow - Chu&#39;s BLoG</title>

    
    
    
    <link rel="stylesheet" href="/css/main.5d65992f9b793fc8ef4d51468c16f848fbe23ebfca8a5cd9508abf8cc4389cc7.css" integrity="sha256-XWWZL5t5P8jvTVFGjBb4SPviPr/KilzZUIq/jMQ4nMc=" />
    <link rel="alternate" href="/index.xml" type="application/atom+xml" title="RSS" />
</head>

<body>
    <header></header>
    <main>
<article>
    <header>
        <h1>CVE-2018-5318：D-Link soap.cgi Stack Buffer Overflow</h1>
        <div>
            <time datetime="2018-01-10 17:40:50 +0800 CST">发布时间: 2018-01-10 17:40</time>
            <time datetime="2018-01-10 17:40:50 +0800 CST">更新时间: 2018-01-10 17:40</time>
        </div>
    </header>

    <section>
    <h2 id="1-前言">1. 前言</h2>
<p>老板前一段给买了几款路由把玩，研究了下 D-Link DIR 629、DIR 823 这两款板子。</p>
<p>发现在 soap.cgi 中存在几处栈溢出，均可以远程利用，并且其他型号的路由也有对 soap 这一部分代码的复用。</p>
<h2 id="2-逆向分析与漏洞挖掘">2. 逆向分析与漏洞挖掘</h2>
<p>因为是想挖几个能远程利用的洞，首先去看了 HTTP 服务，也就是 /htdocs/cgibin。</p>
<p>D-Link HTTP 服务由 cgibin 提供，并通过软链接的文件名进入到不同的处理分支：</p>
<p><img src="1.jpeg" alt=""></p>
<p>在各个 cgi 处理函数中，会通过 <code>cgibin_parse_request</code> 来解析用户输入，其函数原型大致如下：</p>
<p><img src="2.jpeg" alt=""></p>
<p>参数 <code>save_param_func</code> 用于传入解析/存储 HTTP 请求的具体 handler，读取 HTTP 请求后使用该 handler 具体处理用户输入。在 <code>soapcgi_main (0x00418E28)</code> 中传入了漏洞函数 <code>vulnerable_sprintf_parser(0x0041893C)</code>：</p>
<p><img src="3.jpeg" alt=""></p>
<p>跟进 <code>vulnerable_sprintf_parser</code> 可以发现程序未进行边界检查便将全局变量 <code>g_http_soapaction</code> 通过 <code>sprintf</code> 写到栈上：</p>
<p><img src="4.jpeg" alt=""></p>
<p><code>g_http_soapaction</code> 来自于 <code>soapcgi_main</code> 中对 HTTP Header SOAPACTION 字段的解析：</p>
<p>取 <code>HTTP_SOAPACTION</code>：</p>
<p><img src="5.jpeg" alt=""></p>
<p>取 <code>#</code> 后的值：</p>
<p><img src="6.jpeg" alt=""></p>
<p>至此漏洞原理已经明了：<code>soapcgi_main</code> 中未进行边界检查便将 HTTP Header 中的 SOAPACTION 字段存储至栈上，导致栈溢出。</p>
<h2 id="3-漏洞利用">3. 漏洞利用</h2>
<p>基础信息：</p>
<p><img src="7.jpeg" alt=""></p>
<p>MIPS 大端序，开启了 NX，未开启 ASLR、PIE，只需要做个 ROP。</p>
<p>溢出的崩溃现场如下：</p>
<p><img src="8.jpeg" alt=""></p>
<p>$S0、$S2-S3、$FP、$SP 指向的内存可控，要编写 ROP 只能在这几个寄存器上做文章，最终用 ropper 在 uClibc 中找了个很不错的 gadget：</p>
<p><img src="9.jpeg" alt=""></p>
<p>现在需要做的就是找到 libc 加载的实际基址。</p>
<p>在隔壁开锁王师傅的指导下把板子拆开，接上串口：</p>
<p><img src="10.jpeg" alt=""></p>
<p>成功获取到 shell：</p>
<p><img src="11.jpeg" alt=""></p>
<p>拿到 shell 后读 /proc/pid/maps 就可以获取到libc的加载基址。</p>
<p>最终编写 ROP 如下：</p>
<p><img src="12.jpeg" alt=""></p>
<p>攻击演示：</p>
<p><img src="13.jpeg" alt=""></p>

    </section>
</article>
</main>
</body>

</html>
